·编译期绑定--函数的入口地址与函数名是在编译时进行绑定的。
·运行期绑定--函数名与函数入口地址在程序编译时无法绑定在一起，只有等运行的时候才能确定函数名与哪一个函数入口绑定在一起。
 <多态的功能就是将函数名动态绑定到函数入口地址。> 在运行期绑定的函数我们称其是多态的。
 &&形成多态具备以下三个条件：
1、必须存在继承关系；
2、继承关系中必须有同名的虚函数；（即有virtual修饰的同名函数）
3、存在基类类型的指针或引用，通过该指针或引用调用虚函数。
eg：
#include<iostream>
using namespace std;
class base
{
public:
    virtual void display(){cout<<"I'm base class!"<<endl;}
};
class derived: public base
{
public:
    virtual void display(){cout<<"I'm derived class!"<<endl;}
};
int main()
{
    base * p = new base;
    p->display();
    delete p;
    p = new derived;
    p->display();
    delete p;
    return 0;
}
运行结果：
   I’m base class!
   I’m derived class!
详情：https://blog.csdn.net/wejoncy/article/details/52049089


--C++虚成员函数
·virtual关键字仅用于函数声明，如果函数是在类外定义，则不需要再加上virtual关键字了，在C++中只有类中的成员函数能被声明为虚函数，而对于顶层函数则不能声明为虚函数，原因很简单，声明虚函数是为了构成多态，而构成多态的第一个条件就是需要继承关系，顶层函数很明显是不具有继承关系的，因此也就不能被声明为虚函数了。
eg：
#include<iostream>
using namespace std;

class base
{
public:
    virtual void display();
};

class derived: public base
{
public:
    virtual void display();

};

void base::display()
{
    cout<<"I'm base class!"<<endl;
}

void derived::display()
{
    cout<<"I'm derived class!"<<endl;
}

int main()
{
    base * p = new base;
    p->display();
    delete p;
    p = new derived;
    p->display();
    delete p;
    return 0;
}
$ 在本例中，我们将两个类中的display函数在类内部声明，类外部定义，当然这么修改并不会改变程序的运行结果。在本例中我们需要注意的是在类内声明时display函数通过在返回类型前添加了virtual关键字而被声明为了虚函数，而在类外定义时，display函数的返回类型前并未添加virtual关键字。
$ 另外在例1中，我们在基类和派生类中的display函数声明时都加上了virtual关键字，以表示将其声明为虚函数，而实际上这是不需要的，我们只需要将基类中的display函数通过virtual关键字声明为虚函数，之后即使在派生类中display函数声明时未加上virtual关键字，但它在所有的派生类中都将自动成为虚函数。
$ 虚函数是具有继承性的。


--C++虚成员寒暑表vtable
详情：http://www.weixueyuan.net/view/6372.html


--C++虚析构函数
·在类中，构造函数用于初始化对象及相关操作，构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表尚不存在，此时就无法去查询虚函数表，因此也就无法得知该调用哪一个构造函数了。
·析构函数则用于销毁对象时完成相应的资源释放工作，析构函数可以被声明为虚函数。
$通常来说，如果基类中存在一个指向动态分配内存的成员变量，并且基类的析构函数中定义了释放该动态分配内存的代码，则应该将基类的析构函数声明为虚函数。


--C++静态成员函数
·只有非静态成员函数才可以成为虚函数，而静态成员函数不能声明为虚函数。


--C++重载、覆盖和遮蔽
·多态函数是指在运行期才将函数入口地址与函数名绑定的函数，仅有虚函数才是多态。但是除了虚函数以外，重载和遮蔽同样具有函数名相同的特征，在此做一下区分。为了说明方便，我们引入函数签名这一概念。函数签名包括函数名和函数参数的个数、顺序以及参数数据类型。
·注：需要注意的是函数签名并不包含函数返回值部分，如果两个函数仅仅只有函数返回值不同，那么系统是无法区分这两个函数的，此时编译器会提示语法错误。

一、重载：函数重载是指两个函数具有相同的函数名，但是函数参数个数或参数类型不同。函数重载多发生在顶层函数之间或者同一个类中，函数重载不需要构成继承关系。
//注：函数重载是编译期绑定，它并不是多态。
 
二、覆盖：覆盖构成条件和多态构成条件是相同的，覆盖是一种函数间的表现关系，而多态描述的是函数的一种性质，二者所描述的其实是同一种语法现象。
·覆盖首先要求有继承关系，其次是要求构成继承关系的两个类中/*必须具有相同函数签名的成员函数*/，并且这两个成员函数/*必须是虚成员函数*/，具备这两个条件后，派生类中的虚成员函数则会覆盖基类中的同名的虚成员函数。如果我们通过基类指针或引用来调用虚成员函数，则会形成多态。
//注：函数覆盖属于运行期绑定，但是要注意如果函数不是虚函数，则无论采用什么方法调用函数均为编译期绑定。如果我们将例6中的基类中的两个virtual关键字去掉，则主函数中调用vir1和vir2函数属于编译期绑定，无论p指向的是派生类对象或者是基类对象，执行的都将会是基类的vir1和vir2函数。

三、遮蔽：函数遮蔽同样要求构成继承关系，构成继承关系的两个类中具有相同函数名的函数，如果这两个函数不够成覆盖关系，则就构成了遮蔽关系。遮蔽理解起来很简单，只要派生类与基类中具有相同函数名（注意不是相同函数签名，只需要相同函数名就可以了）并且不构成覆盖关系即为遮蔽。
两种情况：
1、非虚函数之间。
2、虚函数之间。








































